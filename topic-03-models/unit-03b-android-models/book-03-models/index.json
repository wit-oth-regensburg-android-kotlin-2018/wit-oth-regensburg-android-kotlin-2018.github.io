


  {
  
  
  "type" : "lab",
  "title" : "Lab-03 Models",
  "img" : "book-03-models/img/main.png",
  "videoid" : "none",
  "objectives" : "<p>Application object + Model classes to manage placemarks.</p>",
    
      "properties" : {},
    
    
      "folder" : "book-03-models",
    
    
      "link" : "book-03-models/index.html",
    
  "los": [
     ]
,
  "chapters" : [
  
    {
    "title": "# Objectives",
    "shortTitle": "Lab-03 Models",
    
     
      
     
    
    "contentMd" : "## Objectives\n\nApplication object + Model classes to manage placemarks. \n"
    
    
      
    
    
    },
  
    {
    "title": " Exercise Solutions",
    "shortTitle": "Exercise Solutions",
    
     
      
     
    
    "contentMd" : "# Exercise Solutions\n\n\n## Exercise 2: Cancel Button\n\nIncorporate new 'Cancel' action into `PlacemarkActivity`. This should return to PlacemarkListActivity without adding a new Placemark.\n\n## strings.xml\n\n~~~\n...\n  <string name=\"menu_cancelPlacemark\">Cancel</string>\n...\n~~~\n\n## menu_placemark.xml\n\nThis resources must be in the `menu` folder in `res`\n\n~~~\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n      xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n  <item\n      android:id=\"@+id/item_cancel\"\n      android:title=\"@string/menu_cancelPlacemark\"\n      app:showAsAction=\"always\"/>\n</menu>\n~~~\n\n## PlacemarkActivity\n\nIn order to present the toolbar - we need to first support it:\n\n~~~\n...\n override fun onCreate(savedInstanceState: Bundle?) {\n    ...\n    toolbarAdd.title = title\n    setSupportActionBar(toolbarAdd)\n    ...\n    }\n  }\n...\n~~~\n\nThen we need to `inflate` the menu:\n\n~~~\n  override fun onCreateOptionsMenu(menu: Menu?): Boolean {\n    menuInflater.inflate(R.menu.menu_placemark, menu)\n    return super.onCreateOptionsMenu(menu)\n  }\n~~~\n\nFinally, we need to handle the event:\n\n~~~\n  override fun onOptionsItemSelected(item: MenuItem?): Boolean {\n    when (item?.itemId) {\n      R.id.item_cancel -> {\n        finish()\n      }\n    }\n    return super.onOptionsItemSelected(item)\n  }\n...\n~~~\n\n\n# Exercise 3: Refactor PlacemarkAdapter to its own source file.\n\nThe PlacemarkAdapter class is currently in the same source file as the PlacemarkListActivity class. For clarity and ease of maintenance, move this into its own source file.\n\n## PlacemarkAdapter\n\n~~~\npackage org.wit.placemark.activities\n\nimport android.support.v7.widget.RecyclerView\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport kotlinx.android.synthetic.main.card_placemark.view.*\nimport org.wit.placemark.R\nimport org.wit.placemark.models.PlacemarkModel\n\nclass PlacemarkAdapter constructor(private var placemarks: List<PlacemarkModel>) : RecyclerView.Adapter<PlacemarkAdapter.MainHolder>() {\n\n  override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): MainHolder {\n    return MainHolder(LayoutInflater.from(parent?.context).inflate(R.layout.card_placemark, parent, false))\n  }\n\n  override fun onBindViewHolder(holder: MainHolder, position: Int) {\n    val placemark = placemarks[holder.adapterPosition]\n    holder.bind(placemark)\n  }\n\n  override fun getItemCount(): Int = placemarks.size\n\n  class MainHolder constructor(itemView: View) : RecyclerView.ViewHolder(itemView) {\n\n    fun bind(placemark: PlacemarkModel) {\n      itemView.placemarkTitle.text = placemark.title\n      itemView.description.text = placemark.description\n    }\n  }\n}\n~~~\n\nDelete the PlacemarkAdapter class from PlacemarkListActivity - and rebuild and run the app now to verify that these changes have been engaged correctly.\n\nCheck the imports in PlacemarkListActivity:\n\n![](img/03.png)\n\nThe greyed out imported are no longer needed (they were used by PlacemarkAdapter). Remove them now and rebuild.\n\n"
    
    
      
    
    
    },
  
    {
    "title": "# Introduce first Model Representation",
    "shortTitle": "02",
    
     
      
     
    
    "contentMd" : "## Introduce first Model Representation\n\nIntroduce the following interface into the `models` package:\n\n## PlacemarkStore\n\n~~~\npackage org.wit.placemark.models\n\ninterface PlacemarkStore {\n  fun findAll(): List<PlacemarkModel>\n  fun create(placemark: PlacemarkModel)\n}\n~~~\n\nIn the same package, implement this interface in a class called PlacemarkMemStore\n\n## PlacemarkMemStore\n\n~~~\npackage org.wit.placemark.models\n\nclass PlacemarkMemStore : PlacemarkStore {\n\n  val placemarks = ArrayList<PlacemarkModel>()\n\n  override fun findAll(): List<PlacemarkModel> {\n    return placemarks\n  }\n\n  override fun create(placemark: PlacemarkModel) {\n    placemarks.add(placemark)\n  }\n}\n~~~\n\nThis is a simple encapsulation of our list of placemarks.\n\nRework all MainApp to use the above class:\n\n## MainApp\n\n~~~\n  // val placemarks = ArrayList<PlacemarkModel>()\n  val placemarks = PlacemarkMemStore()\n~~~\n\n## PlacemarkListActivity\n\n~~~\n  // recyclerView.adapter = PlacemarkAdapter(app.placemarks)\n  recyclerView.adapter = PlacemarkAdapter(app.placemarks.findAll())\n~~~\n\n## PlacemarkActivity\n\n~~~\n  // app.placemarks.add(placemark.copy())\n  app.placemarks.create(placemark.copy())\n\n  ...\n  // app.placemarks.forEach { info(\"add Button Pressed: ${it}\") }\n  app.placemarks.findAll().forEach{ info(\"add Button Pressed: ${it}\") }\n  ...\n~~~\n\n## Logging\n\nIntroduce a new method in PlacemarkMemStore which will log all placemarks. Call it whenever a new placemark is added.\n\n## PlacemarkMemStore\n\n~~~\n...\n  override fun create(placemark: PlacemarkModel) {\n    placemarks.add(placemark)\n    logAll()\n  }\n\n  fun logAll() {\n   placemarks.forEach{ info(\"${it}\") }\n  }\n...\n~~~\n\n\nFor the above to compile, you will. need to adjust the class declaration:\n\n~~~\nclass PlacemarkMemStore : PlacemarkStore, AnkoLogger {\n~~~\n\nWe can now remove the current logging from PlacemarkActivity:\n\n## PlacemarkActivity\n\n~~~\n        info(\"add Button Pressed: $placemarkTitle\")\n        // app.placemarks.findAll().forEach{ info(\"add Button Pressed: ${it}\") }\n~~~\n\n\n\n\n"
    
    
      
    
    
    },
  
    {
    "title": "# PlacemarkListner",
    "shortTitle": "03",
    
     
      
     
    
    "contentMd" : "## PlacemarkListner\n\nIn PlacemarkAdapter, introduce this new interface:\n\n## PlacemarkAdapter\n\n~~~\ninterface PlacemarkListener {\n  fun onPlacemarkClick(placemark: PlacemarkModel)\n}\n~~~\n\nPlace it just before the PlacemarkAdapter class (outside the class).\n\nThis new interface will represent click events on the placemark Card, and allow us to abstract the response to this event.\n\n\nHere is a revised version of the Adapter - which accepts and installs an event handler based on this interface:\n\n~~~\n\nclass PlacemarkAdapter constructor(private var placemarks: List<PlacemarkModel>,\n                                   private val listener: PlacemarkListener) : RecyclerView.Adapter<PlacemarkAdapter.MainHolder>() {\n\n  override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MainHolder {\n    return MainHolder(LayoutInflater.from(parent?.context).inflate(R.layout.card_placemark, parent, false))\n  }\n\n  override fun onBindViewHolder(holder: MainHolder, position: Int) {\n    val placemark = placemarks[holder.adapterPosition]\n    holder.bind(placemark, listener)\n  }\n\n  override fun getItemCount(): Int = placemarks.size\n\n  class MainHolder constructor(itemView: View) : RecyclerView.ViewHolder(itemView) {\n\n    fun bind(placemark: PlacemarkModel,  listener : PlacemarkListener) {\n      itemView.placemarkTitle.text = placemark.title\n      itemView.description.text = placemark.description\n      itemView.setOnClickListener { listener.onPlacemarkClick(placemark) }\n    }\n  }\n}\n~~~\n\nLook carefully at the very last line of the bind function above:\n\n~~~\n      itemView.setOnClickListener { listener.onPlacemarkClick(placemark) }\n~~~\n\nCan you figure our that is going on here?\n\nPerhaps if we now use this capability in PlacemarkListActivity it will become clearer.\n\n## PlacemarkListActivity\n\nFirst, declare that we will implement the new interface:\n\n~~~\nclass PlacemarkListActivity : AppCompatActivity(), PlacemarkListener {\n~~~\n\n... then the actual implementation:\n\n~~~\n  override fun onPlacemarkClick(placemark: PlacemarkModel) {\n    startActivityForResult(intentFor<PlacemarkActivity>(), 0)\n  }\n~~~\n\nFinally, in onCreate, change the way we create the adapter:\n\n~~~\n    recyclerView.adapter = PlacemarkAdapter(app.placemarks.findAll(), this)\n~~~\n\nIf you run the app now - and add some placemarks. Selecting a placemark from the list will start the PlacemarkActivity. However, the Placemark we select will not appear in the PlacemarkActivity view. We will fix this in the next steps.\n\n"
    
    
      
    
    
    },
  
    {
    "title": "# Parcelable",
    "shortTitle": "04",
    
     
      
     
    
    "contentMd" : "## Parcelable\n\nWe will switch on some additional Kotlin goodness - which will significantly simplify the next set of features.\n\n## build.gradle\n\nBefore the dependencies:\n\n~~~\nandroidExtensions {\n  experimental = true\n}\n~~~\n\nThese experimental features are discussed here:\n\n- <https://kotlinlang.org/docs/tutorials/android-plugin.html>\n\nThey are not without some issues - but quite usable.\n\nThis is a revised version of the PlacemarkModel class:\n\n~~~\npackage org.wit.placemark.models\n\nimport android.os.Parcelable\nimport kotlinx.android.parcel.Parcelize\n\n@Parcelize\ndata class PlacemarkModel(var title: String = \"\",\n                          var description: String = \"\") : Parcelable\n~~~\n\nIt implements a parcelize capability. This is discussed in detail here:\n\n- <https://medium.com/@BladeCoder/reducing-parcelable-boilerplate-code-using-kotlin-741c3124a49a>\n\n...but this was written without using the new feature we have just enabled, which dramatically reduces the boilerplate even further. Our approach is discussed here:\n\n- <https://kotlinlang.org/docs/tutorials/android-plugin.html>\n\n(towards the end)\n\n\n"
    
    
      
    
    
    },
  
    {
    "title": " StartActivityWithData",
    "shortTitle": "05",
    
     
      
     
    
    "contentMd" : "# StartActivityWithData\n\nWe can now pass the selected placemark when we start PlacemarkActivity:\n\nChange the current onPlacemarkClick implementation:\n\n## PlacemarkListActivity\n\n~~~\n  override fun onPlacemarkClick(placemark: PlacemarkModel) {\n    startActivityForResult(intentFor<PlacemarkActivity>(), 0)\n  }\n~~~\n\nto this:\n\n~~~\n  override fun onPlacemarkClick(placemark: PlacemarkModel) {\n    startActivityForResult(intentFor<PlacemarkActivity>().putExtra(\"placemark_edit\", placemark), 0)\n  }\n~~~\n\nNotice we are passing the selected placemark to the activity - this is enabled via the `parcelable` mechanism we have just turned on.\n\nNow, in PlacemarkActivity, we can retrieve the placemark in `onCreate()`\n\n~~~\n  override fun onCreate(savedInstanceState: Bundle?) {\n\n    ...\n    if (intent.hasExtra(\"placemark_edit\")) {\n      placemark = intent.extras.getParcelable<PlacemarkModel>(\"placemark_edit\")\n      placemarkTitle.setText(placemark.title)\n      description.setText(placemark.description)\n    }\n    ...\n  }\n~~~\n\nPlace this before the `btnAdd.setOnClickListener()` statement.\n\nWe read back the placemark, and place its field into the view controls.\n\nRun the app now - and verify that if you select a placemark - you will be taken to the PlacemakrActivity containing its values."
    
    
      
    
    
    },
  
    {
    "title": " Ids",
    "shortTitle": "06",
    
     
      
     
    
    "contentMd" : "# Ids\n\nCurrently, we 'edit' a placemark, make a change - then it will create a new placemark. This clearly is not the appropriate behavior. We should update the placemark we have been passed.\n\nTo do this, we need a unique way of identifying placemarks - this is usually via an id. This is the current model:\n\n~~~\n@Parcelize\ndata class PlacemarkModel(var title: String = \"\",\n                          var description: String = \"\") : Parcelable\n~~~\n\nThis is a revised version to include an ID:\n\n~~~\n@Parcelize\ndata class PlacemarkModel(var id: Long = 0,\n                          var title: String = \"\",\n                          var description: String = \"\") : Parcelable\n\n~~~\n\nWe can now introduce a new method in PlacemarkStore interface:\n\n\n## PlacemarkStore\n\n~~~\n...\n  fun update(placemark: PlacemarkModel)\n...\n~~~\n\n... and this is the completely revised PlacemarkMemStore implementation:\n\n~~~\npackage org.wit.placemark.models\n\nimport org.jetbrains.anko.AnkoLogger\nimport org.jetbrains.anko.info\n\nvar lastId = 0L\n\ninternal fun getId(): Long {\n  return lastId++\n}\n\nclass PlacemarkMemStore : PlacemarkStore, AnkoLogger {\n\n  val placemarks = ArrayList<PlacemarkModel>()\n\n  override fun findAll(): List<PlacemarkModel> {\n    return placemarks\n  }\n\n  override fun create(placemark: PlacemarkModel) {\n    placemark.id = getId()\n    placemarks.add(placemark)\n    logAll()\n  }\n\n  override fun update(placemark: PlacemarkModel) {\n    var foundPlacemark: PlacemarkModel? = placemarks.find { p -> p.id == placemark.id }\n    if (foundPlacemark != null) {\n      foundPlacemark.title = placemark.title\n      foundPlacemark.description = placemark.description\n      logAll()\n    }\n  }\n\n  fun logAll() {\n    placemarks.forEach { info(\"${it}\") }\n  }\n}\n~~~\n\nNotice how we are generating a new ID when we create placemarks.\n\nThese features will enable us to implement a placemark edit behaviour.\n"
    
    
      
    
    
    },
  
    {
    "title": "Solution",
    "shortTitle": "Exercises",
    
     
      
     
    
    "contentMd" : "#Solution\n\nPlacemark application so far:\n\n- [placemark-03.zip](archives/placemark-03.zip)\n\n## Exercise 1: String Resources\n\nIn PlacemarkActivity - we have the following hard coded string:\n\n## PlacemarkActivity\n~~~\n  toast(\"Please Enter a title\")\n~~~\n\nThese strings should be in the strings.xml resource file. Move them in there, and figure out how to load the strings in PlacemarkActivity.\n\nFor guidance, see:\n\n- <https://developer.android.com/guide/topics/resources/string-resource.html>\n- <https://stackoverflow.com/questions/44871481/how-can-i-access-values-from-strings-xml-in-kotlin-android>\n\n\n## Exercise 2: Add Button Label\n\nWhen you select a placemark - and the PlacemarkActivity is launched, the button label is 'Add Placemark'. See if you can change this to 'Save Placemark'. This is only to be changed if PlacemarkActivity is launched with a placemark passed to it. Make sure the `Save Placemark` string is externalized (in strings.xml)\n\n\n## Exercise 3 \n\nWhen you select a placemark from PlacemarkListActivity - it presents the activity in the PlacemarkActivity. If you press 'Save Activity' - a new activity is created and appended to the list.\n\nChange this behaviour such that the button should update the existing placemark with the newly entered values, not create a new one.  We have new features in PlacemarkStore to enable you to implement this (the update method). Essentially, you will need to call update OR create when handling the button event.\n\nIf you complete the implementation, you will notice that even if you update a Placemark's contents, the new contents will not be displayed in PlacemarkList. However, if you consult the logs you may be able to see if the values are actually changed.\n\nIf you have trouble finding the correct logs, enter `PlacemarkModel` in the expression window in logcat. This should remove all logs except the ones you want to see:\n\n![](img/04.png)\n\n\n\n\n"
    
    
      
    
    
    }
  
  ]
  }

