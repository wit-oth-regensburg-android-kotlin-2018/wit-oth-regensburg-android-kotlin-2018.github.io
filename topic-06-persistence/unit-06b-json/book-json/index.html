<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.10/semantic.min.css"
        type="text/css">
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/railscasts.min.css"
        rel="stylesheet"/>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/jquery.address/1.6/jquery.address.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.10/semantic.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <style>
    

body {
  font-family: "Open Sans", "Helvetica", "Helvetica Neue",  "Arial", sans-serif;
  font-size:90%;
  color: black;
}

p {
  margin: 0.5em;
}

pre code {
  font-family: "Monaco";
  font-size: 100%;
}

img {
  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
  margin:10px;
}

h1, h2, h3 {
  border-bottom:thin solid black;
  margin-bottom: 0.5em;
  margin-top: 1em;
}

h1 {
  font-style:italic;
  font-size:130%;
}

h2 {
  font-size:110%;
}

h3 {
  font-size:100%;
}



  </style>
</head>

<body>



<div class="ui fixed top pointing inverted stackable menu labmenu">
  <header class="header item">
    <i id="toc" class="sitemap icon"></i>
    
      <a href="../../index.html"> Persistence  </a>
    
  </header>
  <div class="right tab-menu menu">
    
      <a class="item" data-tab="Lab-06 JSON">
        Lab-06 JSON
      </a>
    
      <a class="item" data-tab="01">
        01
      </a>
    
      <a class="item" data-tab="02">
        02
      </a>
    
      <a class="item" data-tab="03">
        03
      </a>
    
      <a class="item" data-tab="04">
        04
      </a>
    
      <a class="item" data-tab="05">
        05
      </a>
    
      <a class="item" data-tab="07">
        07
      </a>
    
      <a class="item" data-tab="Exercises">
        Exercises
      </a>
    
  </div>
</div>

<div class="ui pushable">
  <div class="ui inverted labeled icon left inline vertical sidebar menu">
    <br><br>
    
      
        <a class="item"
           href="https://wit-oth-regensburg-android-kotlin-2018.github.io//topic-00-overview/unit-2-android/book-00-studio/index.html">Lab-00 Studio </a>
      
    
      
        <a class="item"
           href="https://wit-oth-regensburg-android-kotlin-2018.github.io//topic-01-activity/unit-01b-android-activitiy/book-01-activity/index.html">Lab-01 Activities </a>
      
    
      
        <a class="item"
           href="https://wit-oth-regensburg-android-kotlin-2018.github.io//topic-02-adapters/unit-02b-android-adapters/book-02-adapters/index.html">Lab-02 Adapters </a>
      
    
      
        <a class="item"
           href="https://wit-oth-regensburg-android-kotlin-2018.github.io//topic-03-models/unit-03b-android-models/book-03-models/index.html">Lab-03 Models </a>
      
    
      
        <a class="item"
           href="https://wit-oth-regensburg-android-kotlin-2018.github.io//topic-04-images/unit-04b-images/book-04-images/index.html">Lab-04 Images </a>
      
    
      
        <a class="item"
           href="https://wit-oth-regensburg-android-kotlin-2018.github.io//topic-05-map-activity/unit-05b-map-activity/book-maps/index.html">Lab-05 MapActivity </a>
      
    
      
        <a class="item"
           href="https://wit-oth-regensburg-android-kotlin-2018.github.io//topic-06-persistence/unit-06b-json/book-json/index.html">Lab-06 JSON </a>
      
    
      
        <a class="item"
           href="https://wit-oth-regensburg-android-kotlin-2018.github.io//topic-07-layouts/unit-07b-map-view/book-0-map-view/index.html">Lab-07 MapView </a>
      
    
  </div>
  <div class="pusher" tabindex="-1">
    <div class="ui basic segment">
      <br>
      
        <div class="ui tab segment lab" data-tab="Lab-06 JSON">
          <h1>Objectives</h1>
<p>Save and restore placemarks from a JSON formatted file</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="01">
          <h1>Exercises</h1>
<h1>Exercise 1</h1>
<p>If you create a new placemark - and set it location, note that when you click on the marker it shows its lat/lng. Move it around - and notice that the lat/lng in the panel never changes (even though it is at a different location).</p>
<p>See if you can fix this - such that it always shows the correct location.</p>
<p>(HINT: look up <code>GoogleMap.OnMarkerClickListener</code> and <code>setSnippet</code>)</p>
<h1>Solution</h1>
<p>Implement OnMarkerClickListener:</p>
<h2>MapsActivity</h2>
<pre><code>class MapsActivity : AppCompatActivity(), OnMapReadyCallback,  GoogleMap.OnMarkerDragListener, GoogleMap.OnMarkerClickListener {


...
  override fun onMarkerClick(marker: Marker): Boolean {
    val loc = LatLng(location.lat, location.lng)
    marker.setSnippet(&quot;GPS : &quot; + loc.toString())
    return false
  }
...</code></pre>
<p>We need to make sure we listen for this event:</p>
<pre><code>  override fun onMapReady(googleMap: GoogleMap) {
    ...
    map.setOnMarkerClickListener(this)
    ...
  }</code></pre>
<p>This should work as expected now.</p>
<h2>Exercise 2</h2>
<p>When you leave the PlacemarkActiviy, the location is not currently stored in the PlacemarkModel correctly. So when you edit a placemark, it is back at the default location.</p>
<p>Fix this by making location part of the placemark model, so we can edit and change the locations for existing markers.</p>
<h1>Solution</h1>
<p>First, extend the model to include additional fields:</p>
<h2>PlacemarkModel</h2>
<pre><code>
@Parcelize
data class PlacemarkModel(var id: Long = 0,
                          var title: String = &quot;&quot;,
                          var description: String = &quot;&quot;,
                          var image: String = &quot;&quot;,
                          var lat : Double = 0.0,
                          var lng: Double = 0.0,
                          var zoom: Float = 0f) : Parcelable</code></pre>
<p>We are still keeping Location model for use with the MapsActivity</p>
<p>Make sure these fields are saved when a placemark us updated:</p>
<h2>PlacemarkMemStore</h2>
<pre><code>  override fun update(placemark: PlacemarkModel) {
    var foundPlacemark: PlacemarkModel? = placemarks.find { p -&gt; p.id == placemark.id }
    if (foundPlacemark != null) {
      foundPlacemark.title = placemark.title
      foundPlacemark.description = placemark.description
      foundPlacemark.image = placemark.image
      foundPlacemark.lat = placemark.lat
      foundPlacemark.lng = placemark.lng
      foundPlacemark.zoom = placemark.zoom
      logAll();
    }
  }</code></pre>
<p>Then, remove Location from being a class member if PlacemarkActivity:</p>
<h2>PlacemarkActivity</h2>
<pre><code> // var location = Location(52.245696, -7.139102, 15f)</code></pre>
<p>Initialise the location from the placemark object (of zoom is not 0.0. in which case we use a default location)</p>
<pre><code>   placemarkLocation.setOnClickListener {
      val location = Location(52.245696, -7.139102, 15f)
      if (placemark.zoom != 0f) {
        location.lat =  placemark.lat
        location.lng = placemark.lng
        location.zoom = placemark.zoom
      }
      startActivityForResult(intentFor&lt;MapsActivity&gt;().putExtra(&quot;location&quot;, location), LOCATION_REQUEST)
    }</code></pre>
<p>Finally, make sure we recover and save the location when the maps activity finishes:</p>
<pre><code>  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    super.onActivityResult(requestCode, resultCode, data)
    when (requestCode) {
      IMAGE_REQUEST -&gt; {
        if (data != null) {
          placemark.image = data.getData().toString()
          placemarkImage.setImageBitmap(readImage(this, resultCode, data))
          chooseImage.setText(R.string.change_placemark_image)
        }
      }
      LOCATION_REQUEST -&gt; {
        if (data != null) {
          val location = data.extras.getParcelable&lt;Location&gt;(&quot;location&quot;)
          placemark.lat = location.lat
          placemark.lng = location.lng
          placemark.zoom = location.zoom
        }
      }
    }
  }</code></pre>

        </div>
      
        <div class="ui tab segment lab" data-tab="02">
          <h1>MainApp &amp; PlacemarkListActivity Adjustments</h1>
<p>First revise how we create the placemarks store object:</p>
<h2>MainApp</h2>
<pre><code>package org.wit.placemark.main

import android.app.Application
import org.jetbrains.anko.AnkoLogger
import org.jetbrains.anko.info
import org.wit.placemark.models.PlacemarkMemStore
import org.wit.placemark.models.PlacemarkStore

class MainApp : Application(), AnkoLogger {

  lateinit var placemarks: PlacemarkStore

  override fun onCreate() {
    super.onCreate()
    placemarks = PlacemarkMemStore()
    info(&quot;Placemark started&quot;)
  }
}</code></pre>
<p>In the above class we are using a lateinit property. We have seen this before - review some of the motivation behind this property</p>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables">https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables</a></li>
</ul>
<p>We also will revise how we load the placemarks in PlacemarkListActivity.</p>
<p>First, introduce these new methods:</p>
<h2>PlacemarkListActivity</h2>
<pre><code>  private fun loadPlacemarks() {
    showPlacemarks(app.placemarks.findAll())
  }

  fun showPlacemarks (placemarks: List&lt;PlacemarkModel&gt;) {
    recyclerView.adapter = PlacemarkAdapter(placemarks, this)
    recyclerView.adapter?.notifyDataSetChanged()
  }</code></pre>
<p>Change onCreate to call loadPlacemarks()</p>
<pre><code>  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_placemark_list)
    app = application as MainApp

    toolbarMain.title = title
    setSupportActionBar(toolbarMain)

    val layoutManager = LinearLayoutManager(this)
    recyclerView.layoutManager = layoutManager
    loadPlacemarks()
  }</code></pre>
<p>Finally, in onActivityResult() we also call loadPlacemarks():</p>
<pre><code>  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    loadPlacemarks()
    super.onActivityResult(requestCode, resultCode, data)
  }</code></pre>
<p>This is the complete class at this stage:</p>
<h2>PlacemarkListActivity</h2>
<pre><code>package org.wit.placemark.activities

import android.content.Intent
import android.support.v7.app.AppCompatActivity
import android.os.Bundle
import android.support.v7.widget.LinearLayoutManager
import android.view.*
import kotlinx.android.synthetic.main.activity_placemark_list.*
import org.jetbrains.anko.intentFor
import org.jetbrains.anko.startActivityForResult
import org.wit.placemark.R
import org.wit.placemark.main.MainApp
import org.wit.placemark.models.PlacemarkModel

class PlacemarkListActivity : AppCompatActivity(), PlacemarkListener {

  lateinit var app: MainApp

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_placemark_list)
    app = application as MainApp
    toolbarMain.title = title
    setSupportActionBar(toolbarMain)

    val layoutManager = LinearLayoutManager(this)
    recyclerView.layoutManager = layoutManager
    recyclerView.adapter = PlacemarkAdapter(app.placemarks.findAll(), this)
    loadPlacemarks()
  }

  private fun loadPlacemarks() {
    showPlacemarks( app.placemarks.findAll())
  }

  fun showPlacemarks (placemarks: List&lt;PlacemarkModel&gt;) {
    recyclerView.adapter = PlacemarkAdapter(placemarks, this)
    recyclerView.adapter?.notifyDataSetChanged()
  }

  override fun onCreateOptionsMenu(menu: Menu?): Boolean {
    menuInflater.inflate(R.menu.menu_main, menu)
    return super.onCreateOptionsMenu(menu)
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
      R.id.item_add -&gt; startActivityForResult&lt;PlacemarkActivity&gt;(0)
    }
    return super.onOptionsItemSelected(item)
  }

  override fun onPlacemarkClick(placemark: PlacemarkModel) {
    startActivityForResult(intentFor&lt;PlacemarkActivity&gt;().putExtra(&quot;placemark_edit&quot;, placemark), 0)
  }

  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    loadPlacemarks()
    super.onActivityResult(requestCode, resultCode, data)
  }
}</code></pre>
<p>Make sure the app continues to run as expected.</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="03">
          <h1>Persistence</h1>
<p>Currently our placemarks are transient - when the app is closed the placemarks are lost. We would like to make them persistent - they are retained between app launches.</p>
<p>There are many strategies for implementing persistence - both local and remote (cloud). We will start with one of the simplest - storing the placemarks in a simple file.</p>
<p>Before we try this, you should get used to exploring the phones&#39; file system. In Studio, select <code>View-&gt;Tools Windows-&gt;Device File Explorer</code>:</p>
<p><img src="img/03.png" alt=""></p>
<p>This reveals the following:</p>
<p><img src="img/04.png" alt=""></p>
<p>In this window, navigate to <code>data/data/org.wit.placemark/files</code></p>
<p><img src="img/05.png" alt=""></p>
<p>We will be monitoring this directory - as it is the default location for an files you write/read in your app.</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="04">
          <h1>FileHelpers</h1>
<p>To keep our file access simple, we introduce some general purpose file helper functions:</p>
<h2>FileHelpers</h2>
<pre><code>package org.wit.placemark.helpers

import android.content.Context
import android.util.Log
import java.io.*

fun write(context: Context, fileName: String, data: String) {
  try {
    val outputStreamWriter = OutputStreamWriter(context.openFileOutput(fileName, Context.MODE_PRIVATE))
    outputStreamWriter.write(data)
    outputStreamWriter.close()
  } catch (e: Exception) {
    Log.e(&quot;Error: &quot;, &quot;Cannot read file: &quot; + e.toString());
  }
}

fun read(context: Context, fileName: String): String {
  var str = &quot;&quot;
  try {
    val inputStream = context.openFileInput(fileName)
    if (inputStream != null) {
      val inputStreamReader = InputStreamReader(inputStream)
      val bufferedReader = BufferedReader(inputStreamReader)
      val partialStr = StringBuilder()
      var done = false
      while (!done) {
        var line = bufferedReader.readLine()
        done = (line == null);
        if (line != null) partialStr.append(line);
      }
      inputStream.close()
      str = partialStr.toString()
    }
  } catch (e: FileNotFoundException) {
    Log.e(&quot;Error: &quot;, &quot;file not found: &quot; + e.toString());
  } catch (e: IOException) {
    Log.e(&quot;Error: &quot;, &quot;cannot read file: &quot; + e.toString());
  }
  return str
}

fun exists(context: Context, filename: String): Boolean {
  val file = context.getFileStreamPath(filename)
  return file.exists()
}</code></pre>
<p>Place this in the existing helpers package.</p>
<p>These functions are using the standard java.io streams facilities. However, they all require an additional paramater of type <code>context</code>, and this is used when opening the file. This context will be unique to each application - and we must make sure to acquire and use it when deailing with file I/O.</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="05">
          <h1>PlacemarkJSONStore</h1>
<p>The Json file format is one of the most ubiquitous and easily understood file formats:</p>
<ul>
<li><a href="http://www.json.org/">http://www.json.org/</a></li>
</ul>
<p>Google has a popular library for converting Java objects to/from Json:</p>
<ul>
<li><a href="https://github.com/google/gson">https://github.com/google/gson</a></li>
</ul>
<p>We will use this library to convert our placemarks.</p>
<p>First, introduce the library as part of the build:</p>
<h2>build.gradle</h2>
<pre><code>  implementation &quot;com.google.code.gson:gson:2.8.5&quot;</code></pre>
<p>We can now bring in another implementation of our PlacemarkStore abstraction:</p>
<h2>PlacemarkJSONStore</h2>
<pre><code>package org.wit.placemark.models

import android.content.Context
import com.google.gson.Gson
import com.google.gson.GsonBuilder
import com.google.gson.reflect.TypeToken
import org.jetbrains.anko.AnkoLogger
import org.wit.placemark.helpers.*
import java.util.*

val JSON_FILE = &quot;placemarks.json&quot;
val gsonBuilder = GsonBuilder().setPrettyPrinting().create()
val listType = object : TypeToken&lt;java.util.ArrayList&lt;PlacemarkModel&gt;&gt;() {}.type

fun generateRandomId(): Long {
  return Random().nextLong()
}

class PlacemarkJSONStore : PlacemarkStore, AnkoLogger {

  val context: Context
  var placemarks = mutableListOf&lt;PlacemarkModel&gt;()

  constructor (context: Context) {
    this.context = context
    if (exists(context, JSON_FILE)) {
      deserialize()
    }
  }

  override fun findAll(): MutableList&lt;PlacemarkModel&gt; {
    return placemarks
  }

  override fun create(placemark: PlacemarkModel) {
    placemark.id = generateRandomId()
    placemarks.add(placemark)
    serialize()
  }


  override fun update(placemark: PlacemarkModel) {
    // todo
  }

  private fun serialize() {
    val jsonString = gsonBuilder.toJson(placemarks, listType)
    write(context, JSON_FILE, jsonString)
  }

  private fun deserialize() {
    val jsonString = read(context, JSON_FILE)
    placemarks = Gson().fromJson(jsonString, listType)
  }
}</code></pre>
<p>Read this class and see if you can follow the implementation. These are a set of one off declarations:</p>
<pre><code>val JSON_FILE = &quot;placemarks.json&quot;
val gsonBuilder = GsonBuilder().setPrettyPrinting().create()
val listType = object : TypeToken&lt;java.util.ArrayList&lt;PlacemarkModel&gt;&gt;() {}.type</code></pre>
<p>These are used in the implementations. These describe the filename, a utility to serialize a java class (pretty printing it) and an object to help in converting a JSON string to a java collection (recognising PlacemarkModels along the way)</p>

        </div>
      
        <div class="ui tab segment lab" data-tab="07">
          <h2>MainApp</h2>
<p>To use the new store, we just need to switch it in the application object:</p>
<pre><code>package org.wit.placemark.main

import android.app.Application
import org.jetbrains.anko.AnkoLogger
import org.jetbrains.anko.info
import org.wit.placemark.models.PlacemarkJSONStore
import org.wit.placemark.models.PlacemarkMemStore
import org.wit.placemark.models.PlacemarkStore

class MainApp : Application(), AnkoLogger {

  lateinit var placemarks: PlacemarkStore

  override fun onCreate() {
    super.onCreate()
    placemarks = PlacemarkJSONStore(applicationContext)
    info(&quot;Placemark started&quot;)
  }
}</code></pre>
<p>No other changes should be neccesssary.</p>
<p>Run the app now - and verify that you can create placemarks. Terminate the app, and see if the placemarks are still there when you relaunch the app.</p>
<p>Delete the app from the phone, and verify that there are no placemarks when you install and run it again.</p>
<p>Finally, locate the actual file in the Device File Explorer:</p>
<p><img src="img/06.png" alt=""></p>

        </div>
      
        <div class="ui tab segment lab" data-tab="Exercises">
          <h2>Solution</h2>
<p>Placemark application so far:</p>
<ul>
<li><a href="archives/placemark-06.zip">placemark-06.zip</a></li>
</ul>
<h2>Exercise 1: Switching Stores</h2>
<p>Change back to using the PlacemarkMemStore instead of PlacemarkStoreRoom. The only change you need to make should be in MainApp.</p>
<p>Try some experiments to make sure the persistence is working as expected:</p>
<ul>
<li>Using MemStore - create some placemarks and then kill the app. Relaunch, and verify that all placemarks are gone</li>
<li>Using RoomStore - try the same experiment. This time the placemarks should persist between application terminations.</li>
</ul>
<h2>Exercise 2: PlacemarkJSONStore update method</h2>
<p>Complete the implementation of the update method in the PlacemarkJSONStore class. Use the corresponding method in PlacemarkMemStore as a guide (and don&#39;t forget to save changes to the file).</p>
<h2>Exercise 3</h2>
<p>Currently we have no way of deleting placemarks. To support delete, you will need to extend the PlacemarkStore to support removal of placemarks, and then implement this in PlacemarkMemStore and PlacemarkJSONStore These are the implementations you will need:</p>
<h2>PlacemarkStore</h2>
<pre><code>  fun delete(placemark: PlacemarkModel)</code></pre>
<p>Introduce this to PlacemarkStore now - and write implementations in <code>PlacemarkMemStore</code> and <code>PlacemarkJSONStore</code> classes :</p>
<h2>PlacemarkMemStore</h2>
<pre><code>  override fun delete(placemark: PlacemarkModel) {
    placemarks.remove(placemark)
  }</code></pre>
<h2>PlacemaekJSONStore</h2>
<pre><code>  override fun delete(placemark: PlacemarkModel) {
    placemarks.remove(placemark)
    serialize()
  }</code></pre>
<p>To trigger the actual deletion introduce a new <code>delete</code> button alongside the <code>cancel</code> button on the PlacemarkActivity. Pressing this button should trigger the delete method.</p>

        </div>
      
    </div>
  </div>
</div>

<script>
  $(document).on('keydown', function(e) {
  e = e || window.event;
  var nextTab;
  switch (e.which || e.keyCode) {
    case 37: // left
      nextTab = $('.tab-menu a[data-tab].active').prev('a[data-tab]');
      if (!nextTab.length) nextTab = $('.tab-menu a[data-tab]').last();
      nextTab.click();
      $('.pusher').focus();
      break;

    case 39: // right
      nextTab = $('.tab-menu a[data-tab].active').next('a[data-tab]');
      if (!nextTab.length) nextTab = $('.tab-menu a[data-tab]').first();
      nextTab.click();
      $('.pusher').focus();
      break;
  }
});

  $(document).ready(function() {
  $('img').addClass('ui image');

  $('.ui.embed').embed();

  const $images = $('.lab img');
  jQuery.each($images, function(i) {
    if ($images[i].alt.length > 0) {
      const divImg = $(document.createElement('div')).addClass(
        'ui basic segment',
      );
      $($images[i]).wrap(divImg);
      const divLabel = $(document.createElement('div')).addClass(
        'ui blue ribbon label',
      );
      divLabel.append($images[i].alt);
      $(divLabel).insertBefore($images[i]);
    }
  });

  $('.ui.menu .item').tab({
    history: true,
    historyType: 'hash',
  });

  $('.popup').popup();

  $('.ui.sidebar')
    .sidebar({ context: $('.pushable') })
    .sidebar('setting', 'transition', 'slide out')
    .sidebar('attach events', '#toc');
});

</script>
</body>
</html>