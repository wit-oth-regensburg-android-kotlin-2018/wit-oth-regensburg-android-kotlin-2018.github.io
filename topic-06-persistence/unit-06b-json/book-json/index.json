


  {
  
  
  "type" : "lab",
  "title" : "Lab-06 JSON",
  "img" : "book-json/img/main.png",
  "videoid" : "none",
  "objectives" : "<p>Save and restore placemarks from a JSON formatted file</p>",
    
      "properties" : {},
    
    
      "folder" : "book-json",
    
    
      "link" : "book-json/index.html",
    
  "los": [
     ]
,
  "chapters" : [
  
    {
    "title": "Objectives",
    "shortTitle": "Lab-06 JSON",
    
     
      
     
    
    "contentMd" : "#Objectives\n\nSave and restore placemarks from a JSON formatted file"
    
    
      
    
    
    },
  
    {
    "title": " Exercises",
    "shortTitle": "01",
    
     
      
     
    
    "contentMd" : "# Exercises\n\n# Exercise 1\n\nIf you create a new placemark - and set it location, note that when you click on the marker it shows its lat/lng. Move it around - and notice that the lat/lng in the panel never changes (even though it is at a different location).\n\nSee if you can fix this - such that it always shows the correct location.\n\n(HINT: look up `GoogleMap.OnMarkerClickListener` and `setSnippet`)\n\n# Solution\n\n\nImplement OnMarkerClickListener:\n\n## MapsActivity\n\n~~~\nclass MapsActivity : AppCompatActivity(), OnMapReadyCallback,  GoogleMap.OnMarkerDragListener, GoogleMap.OnMarkerClickListener {\n\n\n...\n  override fun onMarkerClick(marker: Marker): Boolean {\n    val loc = LatLng(location.lat, location.lng)\n    marker.setSnippet(\"GPS : \" + loc.toString())\n    return false\n  }\n...\n~~~\n\nWe need to make sure we listen for this event:\n\n~~~\n  override fun onMapReady(googleMap: GoogleMap) {\n    ...\n    map.setOnMarkerClickListener(this)\n    ...\n  }\n~~~\n\nThis should work as expected now.\n\n## Exercise 2\n\nWhen you leave the PlacemarkActiviy, the location is not currently stored in the PlacemarkModel correctly. So when you edit a placemark, it is back at the default location.\n\nFix this by making location part of the placemark model, so we can edit and change the locations for existing markers.\n\n# Solution\n\nFirst, extend the model to include additional fields:\n\n## PlacemarkModel\n\n~~~\n\n@Parcelize\ndata class PlacemarkModel(var id: Long = 0,\n                          var title: String = \"\",\n                          var description: String = \"\",\n                          var image: String = \"\",\n                          var lat : Double = 0.0,\n                          var lng: Double = 0.0,\n                          var zoom: Float = 0f) : Parcelable\n~~~\n\nWe are still keeping Location model for use with the MapsActivity\n\nMake sure these fields are saved when a placemark us updated:\n\n## PlacemarkMemStore\n\n~~~\n  override fun update(placemark: PlacemarkModel) {\n    var foundPlacemark: PlacemarkModel? = placemarks.find { p -> p.id == placemark.id }\n    if (foundPlacemark != null) {\n      foundPlacemark.title = placemark.title\n      foundPlacemark.description = placemark.description\n      foundPlacemark.image = placemark.image\n      foundPlacemark.lat = placemark.lat\n      foundPlacemark.lng = placemark.lng\n      foundPlacemark.zoom = placemark.zoom\n      logAll();\n    }\n  }\n~~~\n\nThen, remove Location from being a class member if PlacemarkActivity:\n\n## PlacemarkActivity\n\n~~~\n // var location = Location(52.245696, -7.139102, 15f)\n~~~\n\nInitialise the location from the placemark object (of zoom is not 0.0. in which case we use a default location)\n~~~\n   placemarkLocation.setOnClickListener {\n      val location = Location(52.245696, -7.139102, 15f)\n      if (placemark.zoom != 0f) {\n        location.lat =  placemark.lat\n        location.lng = placemark.lng\n        location.zoom = placemark.zoom\n      }\n      startActivityForResult(intentFor<MapsActivity>().putExtra(\"location\", location), LOCATION_REQUEST)\n    }\n~~~\n\nFinally, make sure we recover and save the location when the maps activity finishes:\n\n~~~\n  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n    super.onActivityResult(requestCode, resultCode, data)\n    when (requestCode) {\n      IMAGE_REQUEST -> {\n        if (data != null) {\n          placemark.image = data.getData().toString()\n          placemarkImage.setImageBitmap(readImage(this, resultCode, data))\n          chooseImage.setText(R.string.change_placemark_image)\n        }\n      }\n      LOCATION_REQUEST -> {\n        if (data != null) {\n          val location = data.extras.getParcelable<Location>(\"location\")\n          placemark.lat = location.lat\n          placemark.lng = location.lng\n          placemark.zoom = location.zoom\n        }\n      }\n    }\n  }\n~~~\n"
    
    
      
    
    
    },
  
    {
    "title": " MainApp & PlacemarkListActivity Adjustments",
    "shortTitle": "02",
    
     
      
     
    
    "contentMd" : "# MainApp & PlacemarkListActivity Adjustments\n\n\nFirst revise how we create the placemarks store object:\n\n## MainApp\n\n~~~\npackage org.wit.placemark.main\n\nimport android.app.Application\nimport org.jetbrains.anko.AnkoLogger\nimport org.jetbrains.anko.info\nimport org.wit.placemark.models.PlacemarkMemStore\nimport org.wit.placemark.models.PlacemarkStore\n\nclass MainApp : Application(), AnkoLogger {\n\n  lateinit var placemarks: PlacemarkStore\n\n  override fun onCreate() {\n    super.onCreate()\n    placemarks = PlacemarkMemStore()\n    info(\"Placemark started\")\n  }\n}\n~~~\n\nIn the above class we are using a lateinit property. We have seen this before - review some of the motivation behind this property\n\n- <https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables>\n\nWe also will revise how we load the placemarks in PlacemarkListActivity.\n\nFirst, introduce these new methods:\n\n\n## PlacemarkListActivity\n\n~~~\n  private fun loadPlacemarks() {\n    showPlacemarks(app.placemarks.findAll())\n  }\n\n  fun showPlacemarks (placemarks: List<PlacemarkModel>) {\n    recyclerView.adapter = PlacemarkAdapter(placemarks, this)\n    recyclerView.adapter?.notifyDataSetChanged()\n  }\n~~~\n\n\nChange onCreate to call loadPlacemarks()\n\n~~~\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_placemark_list)\n    app = application as MainApp\n\n    toolbarMain.title = title\n    setSupportActionBar(toolbarMain)\n\n    val layoutManager = LinearLayoutManager(this)\n    recyclerView.layoutManager = layoutManager\n    loadPlacemarks()\n  }\n~~~\n\nFinally, in onActivityResult() we also call loadPlacemarks():\n\n~~~\n  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n    loadPlacemarks()\n    super.onActivityResult(requestCode, resultCode, data)\n  }\n~~~\n\n\nThis is the complete class at this stage:\n\n\n## PlacemarkListActivity\n\n~~~\npackage org.wit.placemark.activities\n\nimport android.content.Intent\nimport android.support.v7.app.AppCompatActivity\nimport android.os.Bundle\nimport android.support.v7.widget.LinearLayoutManager\nimport android.view.*\nimport kotlinx.android.synthetic.main.activity_placemark_list.*\nimport org.jetbrains.anko.intentFor\nimport org.jetbrains.anko.startActivityForResult\nimport org.wit.placemark.R\nimport org.wit.placemark.main.MainApp\nimport org.wit.placemark.models.PlacemarkModel\n\nclass PlacemarkListActivity : AppCompatActivity(), PlacemarkListener {\n\n  lateinit var app: MainApp\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_placemark_list)\n    app = application as MainApp\n    toolbarMain.title = title\n    setSupportActionBar(toolbarMain)\n\n    val layoutManager = LinearLayoutManager(this)\n    recyclerView.layoutManager = layoutManager\n    recyclerView.adapter = PlacemarkAdapter(app.placemarks.findAll(), this)\n    loadPlacemarks()\n  }\n\n  private fun loadPlacemarks() {\n    showPlacemarks( app.placemarks.findAll())\n  }\n\n  fun showPlacemarks (placemarks: List<PlacemarkModel>) {\n    recyclerView.adapter = PlacemarkAdapter(placemarks, this)\n    recyclerView.adapter?.notifyDataSetChanged()\n  }\n\n  override fun onCreateOptionsMenu(menu: Menu?): Boolean {\n    menuInflater.inflate(R.menu.menu_main, menu)\n    return super.onCreateOptionsMenu(menu)\n  }\n\n  override fun onOptionsItemSelected(item: MenuItem?): Boolean {\n    when (item?.itemId) {\n      R.id.item_add -> startActivityForResult<PlacemarkActivity>(0)\n    }\n    return super.onOptionsItemSelected(item)\n  }\n\n  override fun onPlacemarkClick(placemark: PlacemarkModel) {\n    startActivityForResult(intentFor<PlacemarkActivity>().putExtra(\"placemark_edit\", placemark), 0)\n  }\n\n  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n    loadPlacemarks()\n    super.onActivityResult(requestCode, resultCode, data)\n  }\n}\n~~~\n\nMake sure the app continues to run as expected.\n"
    
    
      
    
    
    },
  
    {
    "title": " Persistence",
    "shortTitle": "03",
    
     
      
     
    
    "contentMd" : "# Persistence\n\nCurrently our placemarks are transient - when the app is closed the placemarks are lost. We would like to make them persistent - they are retained between app launches.\n\nThere are many strategies for implementing persistence - both local and remote (cloud). We will start with one of the simplest - storing the placemarks in a simple file.\n\nBefore we try this, you should get used to exploring the phones' file system. In Studio, select `View->Tools Windows->Device File Explorer`:\n\n![](img/03.png)\n\nThis reveals the following:\n\n![](img/04.png)\n\nIn this window, navigate to `data/data/org.wit.placemark/files`\n\n![](img/05.png)\n\nWe will be monitoring this directory - as it is the default location for an files you write/read in your app."
    
    
      
    
    
    },
  
    {
    "title": " FileHelpers",
    "shortTitle": "04",
    
     
      
     
    
    "contentMd" : "# FileHelpers\n\nTo keep our file access simple, we introduce some general purpose file helper functions:\n\n\n## FileHelpers\n\n~~~\npackage org.wit.placemark.helpers\n\nimport android.content.Context\nimport android.util.Log\nimport java.io.*\n\nfun write(context: Context, fileName: String, data: String) {\n  try {\n    val outputStreamWriter = OutputStreamWriter(context.openFileOutput(fileName, Context.MODE_PRIVATE))\n    outputStreamWriter.write(data)\n    outputStreamWriter.close()\n  } catch (e: Exception) {\n    Log.e(\"Error: \", \"Cannot read file: \" + e.toString());\n  }\n}\n\nfun read(context: Context, fileName: String): String {\n  var str = \"\"\n  try {\n    val inputStream = context.openFileInput(fileName)\n    if (inputStream != null) {\n      val inputStreamReader = InputStreamReader(inputStream)\n      val bufferedReader = BufferedReader(inputStreamReader)\n      val partialStr = StringBuilder()\n      var done = false\n      while (!done) {\n        var line = bufferedReader.readLine()\n        done = (line == null);\n        if (line != null) partialStr.append(line);\n      }\n      inputStream.close()\n      str = partialStr.toString()\n    }\n  } catch (e: FileNotFoundException) {\n    Log.e(\"Error: \", \"file not found: \" + e.toString());\n  } catch (e: IOException) {\n    Log.e(\"Error: \", \"cannot read file: \" + e.toString());\n  }\n  return str\n}\n\nfun exists(context: Context, filename: String): Boolean {\n  val file = context.getFileStreamPath(filename)\n  return file.exists()\n}\n~~~\n\nPlace this in the existing helpers package.\n\nThese functions are using the standard java.io streams facilities. However, they all require an additional paramater of type `context`, and this is used when opening the file. This context will be unique to each application - and we must make sure to acquire and use it when deailing with file I/O."
    
    
      
    
    
    },
  
    {
    "title": " PlacemarkJSONStore",
    "shortTitle": "05",
    
     
      
     
    
    "contentMd" : "# PlacemarkJSONStore\n\n\nThe Json file format is one of the most ubiquitous and easily understood file formats:\n\n- <http://www.json.org/>\n\nGoogle has a popular library for converting Java objects to/from Json:\n\n- <https://github.com/google/gson>\n\nWe will use this library to convert our placemarks.\n\nFirst, introduce the library as part of the build:\n\n## build.gradle\n\n~~~\n  implementation \"com.google.code.gson:gson:2.8.5\"\n~~~\n\nWe can now bring in another implementation of our PlacemarkStore abstraction:\n\n\n## PlacemarkJSONStore\n\n~~~\npackage org.wit.placemark.models\n\nimport android.content.Context\nimport com.google.gson.Gson\nimport com.google.gson.GsonBuilder\nimport com.google.gson.reflect.TypeToken\nimport org.jetbrains.anko.AnkoLogger\nimport org.wit.placemark.helpers.*\nimport java.util.*\n\nval JSON_FILE = \"placemarks.json\"\nval gsonBuilder = GsonBuilder().setPrettyPrinting().create()\nval listType = object : TypeToken<java.util.ArrayList<PlacemarkModel>>() {}.type\n\nfun generateRandomId(): Long {\n  return Random().nextLong()\n}\n\nclass PlacemarkJSONStore : PlacemarkStore, AnkoLogger {\n\n  val context: Context\n  var placemarks = mutableListOf<PlacemarkModel>()\n\n  constructor (context: Context) {\n    this.context = context\n    if (exists(context, JSON_FILE)) {\n      deserialize()\n    }\n  }\n\n  override fun findAll(): MutableList<PlacemarkModel> {\n    return placemarks\n  }\n\n  override fun create(placemark: PlacemarkModel) {\n    placemark.id = generateRandomId()\n    placemarks.add(placemark)\n    serialize()\n  }\n\n\n  override fun update(placemark: PlacemarkModel) {\n    // todo\n  }\n\n  private fun serialize() {\n    val jsonString = gsonBuilder.toJson(placemarks, listType)\n    write(context, JSON_FILE, jsonString)\n  }\n\n  private fun deserialize() {\n    val jsonString = read(context, JSON_FILE)\n    placemarks = Gson().fromJson(jsonString, listType)\n  }\n}\n~~~\n\nRead this class and see if you can follow the implementation. These are a set of one off declarations:\n\n~~~\nval JSON_FILE = \"placemarks.json\"\nval gsonBuilder = GsonBuilder().setPrettyPrinting().create()\nval listType = object : TypeToken<java.util.ArrayList<PlacemarkModel>>() {}.type\n~~~\n\nThese are used in the implementations. These describe the filename, a utility to serialize a java class (pretty printing it) and an object to help in converting a JSON string to a java collection (recognising PlacemarkModels along the way)\n\n\n\n"
    
    
      
    
    
    },
  
    {
    "title": "# MainApp",
    "shortTitle": "07",
    
     
      
     
    
    "contentMd" : "## MainApp\n\nTo use the new store, we just need to switch it in the application object:\n\n~~~\npackage org.wit.placemark.main\n\nimport android.app.Application\nimport org.jetbrains.anko.AnkoLogger\nimport org.jetbrains.anko.info\nimport org.wit.placemark.models.PlacemarkJSONStore\nimport org.wit.placemark.models.PlacemarkMemStore\nimport org.wit.placemark.models.PlacemarkStore\n\nclass MainApp : Application(), AnkoLogger {\n\n  lateinit var placemarks: PlacemarkStore\n\n  override fun onCreate() {\n    super.onCreate()\n    placemarks = PlacemarkJSONStore(applicationContext)\n    info(\"Placemark started\")\n  }\n}\n~~~\n\nNo other changes should be neccesssary.\n\nRun the app now - and verify that you can create placemarks. Terminate the app, and see if the placemarks are still there when you relaunch the app.\n\nDelete the app from the phone, and verify that there are no placemarks when you install and run it again.\n\nFinally, locate the actual file in the Device File Explorer:\n\n![](img/06.png)"
    
    
      
    
    
    },
  
    {
    "title": "# Solution",
    "shortTitle": "Exercises",
    
     
      
     
    
    "contentMd" : "## Solution\n\nPlacemark application so far:\n\n- [placemark-06.zip](archives/placemark-06.zip)\n\n## Exercise 1: Switching Stores\n\nChange back to using the PlacemarkMemStore instead of PlacemarkStoreRoom. The only change you need to make should be in MainApp.\n\nTry some experiments to make sure the persistence is working as expected:\n\n- Using MemStore - create some placemarks and then kill the app. Relaunch, and verify that all placemarks are gone\n- Using RoomStore - try the same experiment. This time the placemarks should persist between application terminations.\n\n\n## Exercise 2: PlacemarkJSONStore update method\n\n\nComplete the implementation of the update method in the PlacemarkJSONStore class. Use the corresponding method in PlacemarkMemStore as a guide (and don't forget to save changes to the file).\n\n## Exercise 3\n\nCurrently we have no way of deleting placemarks. To support delete, you will need to extend the PlacemarkStore to support removal of placemarks, and then implement this in PlacemarkMemStore and PlacemarkJSONStore These are the implementations you will need:\n\n## PlacemarkStore\n\n~~~\n  fun delete(placemark: PlacemarkModel)\n~~~\n\nIntroduce this to PlacemarkStore now - and write implementations in `PlacemarkMemStore` and `PlacemarkJSONStore` classes :\n\n## PlacemarkMemStore\n\n~~~\n  override fun delete(placemark: PlacemarkModel) {\n    placemarks.remove(placemark)\n  }\n~~~\n\n## PlacemaekJSONStore\n\n\n~~~\n  override fun delete(placemark: PlacemarkModel) {\n    placemarks.remove(placemark)\n    serialize()\n  }\n~~~\n\nTo trigger the actual deletion introduce a new `delete` button alongside the `cancel` button on the PlacemarkActivity. Pressing this button should trigger the delete method.\n"
    
    
      
    
    
    }
  
  ]
  }

