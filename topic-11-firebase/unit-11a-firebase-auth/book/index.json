


  {
  
  
    "properties" : {},
  
  "type" : "lab",
  "title" : "Lab-11a Firebase Auth",
  "img" : "img/main.png",
  "videoid" : "none",
  "objectives" : "<p>Authenticate users against the Firebase Authentication service</p>",
  "folder" : "book",
  "link" : "index.html",
  "los": [
   ]
,
  "chapters" : [
  
    {
    "title": "#Objectives",
    "shortTitle": "Lab-11a Firebase Auth",
    "contentMd" : "#Objectives\n\nAuthenticate users against the Firebase Authentication service"
    },
  
    {
    "title": "# Exercise",
    "shortTitle": "01",
    "contentMd" : "# Exercise\n\nRework the PlacemarkModel so that, instead repeating lat/lng/zoom in each placemark, we embed a Location object. In order to implement this in the context of the Room system, you will need to use the `@Embedded` annotation:\n\n- <https://developer.android.com/reference/android/arch/persistence/room/Embedded>\n\nAlso, you will also have to adjust the other Store implementations.\n\n## Solution\n\nRevised PlacemarkModel:\n\n## PlacemarkModel\n\n~~~\npackage org.wit.placemark.models\n\nimport android.os.Parcelable\nimport androidx.room.Embedded\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport kotlinx.android.parcel.Parcelize\n\n@Parcelize\n@Entity\ndata class PlacemarkModel(@PrimaryKey(autoGenerate = true) var id: Long = 0,\n                          var title: String = \"\",\n                          var description: String = \"\",\n                          var image: String = \"\",\n                          @Embedded var location : Location = Location()): Parcelable\n\n@Parcelize\ndata class Location(var lat: Double = 0.0,\n                    var lng: Double = 0.0,\n                    var zoom: Float = 0f) : Parcelable\n~~~\n\nRevised update methods in some existing PlacemarmStore implementations:\n\n## PlacemarkMemStore\n\n~~~\n  suspend override fun update(placemark: PlacemarkModel) {\n    var foundPlacemark: PlacemarkModel? = placemarks.find { p -> p.id == placemark.id }\n    if (foundPlacemark != null) {\n      foundPlacemark.title = placemark.title\n      foundPlacemark.description = placemark.description\n      foundPlacemark.image = placemark.image\n      foundPlacemark.location = placemark.location\n      logAll();\n    }\n  }\n~~~\n\n\n## PlacemarkJSONStore\n\n~~~\n  suspend override fun update(placemark: PlacemarkModel) {\n    val placemarksList = findAll() as ArrayList<PlacemarkModel>\n    var foundPlacemark: PlacemarkModel? = placemarksList.find { p -> p.id == placemark.id }\n    if (foundPlacemark != null) {\n      foundPlacemark.title = placemark.title\n      foundPlacemark.description = placemark.description\n      foundPlacemark.image = placemark.image\n      foundPlacemark.location = placemark.location\n    }\n    serialize()\n  }\n~~~\n\nOne View will need revision:\n\n## PlacemarkView\n\n~~~\n...\n    lat.setText(\"%.6f\".format(placemark.location.lat))\n    lng.setText(\"%.6f\".format(placemark.location.lng))\n...\n~~~\n\nWe can rework the PlacemarkPresenter to be marginally simplified:\n\n\n## PlacemarkPresenter\n\n~~~\npackage org.wit.placemark.views.placemark\n\nimport android.annotation.SuppressLint\nimport android.content.Intent\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationCallback\nimport com.google.android.gms.location.LocationResult\nimport com.google.android.gms.location.LocationServices\nimport com.google.android.gms.maps.CameraUpdateFactory\nimport com.google.android.gms.maps.GoogleMap\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.android.gms.maps.model.MarkerOptions\nimport kotlinx.coroutines.experimental.android.UI\nimport kotlinx.coroutines.experimental.async\nimport org.wit.placemark.helpers.checkLocationPermissions\nimport org.wit.placemark.helpers.createDefaultLocationRequest\nimport org.wit.placemark.helpers.isPermissionGranted\nimport org.wit.placemark.helpers.showImagePicker\nimport org.wit.placemark.models.Location\nimport org.wit.placemark.models.PlacemarkModel\nimport org.wit.placemark.views.*\n\nclass PlacemarkPresenter(view: BaseView) : BasePresenter(view) {\n\n  var map: GoogleMap? = null\n  var placemark = PlacemarkModel()\n  var defaultLocation = Location(52.245696, -7.139102, 15f)\n  var edit = false;\n  var locationService: FusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(view)\n  val locationRequest = createDefaultLocationRequest()\n\n  init {\n    if (view.intent.hasExtra(\"placemark_edit\")) {\n      edit = true\n      placemark = view.intent.extras.getParcelable<PlacemarkModel>(\"placemark_edit\")\n      view.showPlacemark(placemark)\n    } else {\n      if (checkLocationPermissions(view)) {\n        doSetCurrentLocation()\n      }\n    }\n  }\n\n  @SuppressLint(\"MissingPermission\")\n  fun doSetCurrentLocation() {\n    locationService.lastLocation.addOnSuccessListener {\n      locationUpdate(Location(it.latitude, it.longitude))\n    }\n  }\n\n  @SuppressLint(\"MissingPermission\")\n  fun doResartLocationUpdates() {\n\n    var locationCallback = object : LocationCallback() {\n      override fun onLocationResult(locationResult: LocationResult?) {\n        if (locationResult != null && locationResult.locations != null) {\n          val l = locationResult.locations.last()\n          locationUpdate(Location(l.latitude, l.longitude))\n        }\n      }\n    }\n    if (!edit) {\n      locationService.requestLocationUpdates(locationRequest, locationCallback, null)\n    }\n  }\n\n  override fun doRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {\n    if (isPermissionGranted(requestCode, grantResults)) {\n      doSetCurrentLocation()\n    } else {\n      locationUpdate(defaultLocation)\n    }\n  }\n\n  fun doConfigureMap(m: GoogleMap) {\n    map = m\n    locationUpdate(placemark.location)\n  }\n\n  fun locationUpdate(location: Location) {\n    placemark.location = location\n    placemark.location.zoom = 15f\n    map?.clear()\n    map?.uiSettings?.setZoomControlsEnabled(true)\n    val options = MarkerOptions().title(placemark.title).position(LatLng(placemark.location.lat, placemark.location.lng))\n    map?.addMarker(options)\n    map?.moveCamera(CameraUpdateFactory.newLatLngZoom(LatLng(placemark.location.lat, placemark.location.lng), placemark.location.zoom))\n    view?.showPlacemark(placemark)\n  }\n\n\n  fun doAddOrSave(title: String, description: String) {\n    placemark.title = title\n    placemark.description = description\n    async(UI) {\n      if (edit) {\n        app.placemarks.update(placemark)\n      } else {\n        app.placemarks.create(placemark)\n      }\n      view?.finish()\n    }\n  }\n\n  fun doCancel() {\n    view?.finish()\n  }\n\n  fun doDelete() {\n    async(UI) {\n      app.placemarks.delete(placemark)\n      view?.finish()\n    }\n  }\n\n  fun doSelectImage() {\n    view?.let {\n      showImagePicker(view!!, IMAGE_REQUEST)\n    }\n  }\n\n  fun doSetLocation() {\n    view?.navigateTo(VIEW.LOCATION, LOCATION_REQUEST, \"location\", Location(placemark.location.lat, placemark.location.lng, placemark.location.zoom))\n  }\n\n  override fun doActivityResult(requestCode: Int, resultCode: Int, data: Intent) {\n    when (requestCode) {\n      IMAGE_REQUEST -> {\n        placemark.image = data.data.toString()\n        view?.showPlacemark(placemark)\n      }\n      LOCATION_REQUEST -> {\n        val location = data.extras.getParcelable<Location>(\"location\")\n        placemark.location = location\n        locationUpdate(location)\n      }\n    }\n  }\n}\n~~~\n\nFinally, PlacemarkMapPresenter:\n\n\n## PlacemarkMapPresenter\n\n~~~\n  fun doPopulateMap(map: GoogleMap, placemarks: List<PlacemarkModel>) {\n    map.uiSettings.setZoomControlsEnabled(true)\n    placemarks.forEach {\n      val loc = LatLng(it.location.lat, it.location.lng)\n      val options = MarkerOptions().title(it.title).position(loc)\n      map.addMarker(options).tag = it.id\n      map.moveCamera(CameraUpdateFactory.newLatLngZoom(loc, it.location.zoom))\n    }\n  }\n\n~~~\n\n\n\n"
    },
  
    {
    "title": "# Login Layout",
    "shortTitle": "02",
    "contentMd" : "# Login Layout\n\nWe would like to introduce a new Login screen - which will be presented before any user logs in:\n\n![](img/01x.png)\n\n\nWe need these new string resources:\n\n## strings.xml\n\n~~~\n  <string name=\"title_activity_login\"> Signup/Login to Placemark</string>\n~~~\n\n\nThis is the login layout:\n\n## res/layout/activity_login.xml\n\n~~~\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n  xmlns:tools=\"http://schemas.android.com/tools\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n  tools:context=\"org.wit.placemark.views.login.LoginView\">\n\n  <com.google.android.material.appbar.AppBarLayout\n    android:id=\"@+id/appBarLayout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"@color/colorAccent\"\n    android:fitsSystemWindows=\"true\"\n    app:elevation=\"0dip\"\n    app:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\">\n\n    <androidx.appcompat.widget.Toolbar\n      android:id=\"@+id/toolbar\"\n      android:layout_width=\"match_parent\"\n      android:layout_height=\"wrap_content\"\n      app:titleTextColor=\"@color/colorPrimary\" />\n\n  </com.google.android.material.appbar.AppBarLayout>\n\n  <androidx.constraintlayout.widget.ConstraintLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:layout_marginStart=\"8dp\"\n    android:layout_marginEnd=\"8dp\"\n    android:layout_marginBottom=\"16dp\"\n    app:layout_constraintBottom_toBottomOf=\"parent\"\n    app:layout_constraintEnd_toEndOf=\"parent\"\n    app:layout_constraintHorizontal_bias=\"0.0\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n    app:layout_constraintVertical_bias=\"0.0\">\n\n\n    <EditText\n      android:id=\"@+id/email\"\n      android:layout_width=\"237dp\"\n      android:layout_height=\"wrap_content\"\n      android:layout_marginStart=\"8dp\"\n      android:layout_marginTop=\"108dp\"\n      android:layout_marginEnd=\"36dp\"\n      android:ems=\"10\"\n      android:inputType=\"textEmailAddress\"\n      app:layout_constraintEnd_toEndOf=\"parent\"\n      app:layout_constraintHorizontal_bias=\"1.0\"\n      app:layout_constraintStart_toEndOf=\"@+id/textView\"\n      app:layout_constraintTop_toTopOf=\"parent\" />\n\n    <TextView\n      android:id=\"@+id/textView\"\n      android:layout_width=\"72dp\"\n      android:layout_height=\"23dp\"\n      android:layout_marginStart=\"16dp\"\n      android:text=\"Email\"\n      android:textAlignment=\"textEnd\"\n      app:layout_constraintBaseline_toBaselineOf=\"@+id/email\"\n      app:layout_constraintStart_toStartOf=\"parent\" />\n\n    <EditText\n      android:id=\"@+id/password\"\n      android:layout_width=\"239dp\"\n      android:layout_height=\"wrap_content\"\n      android:layout_marginTop=\"8dp\"\n      android:ems=\"10\"\n      android:inputType=\"textPassword\"\n      app:layout_constraintBottom_toBottomOf=\"parent\"\n      app:layout_constraintEnd_toEndOf=\"@+id/email\"\n      app:layout_constraintHorizontal_bias=\"0.0\"\n      app:layout_constraintStart_toStartOf=\"@+id/email\"\n      app:layout_constraintTop_toBottomOf=\"@+id/email\"\n      app:layout_constraintVertical_bias=\"0.026\" />\n\n    <TextView\n      android:id=\"@+id/textView2\"\n      android:layout_width=\"70dp\"\n      android:layout_height=\"29dp\"\n      android:text=\"Password\"\n      android:textAlignment=\"textEnd\"\n      app:layout_constraintBaseline_toBaselineOf=\"@+id/password\"\n      app:layout_constraintEnd_toEndOf=\"@+id/textView\"\n      app:layout_constraintHorizontal_bias=\"1.0\"\n      app:layout_constraintStart_toStartOf=\"@+id/textView\" />\n\n    <Button\n      android:id=\"@+id/signUp\"\n      android:layout_width=\"169dp\"\n      android:layout_height=\"wrap_content\"\n      android:layout_marginStart=\"8dp\"\n      android:layout_marginTop=\"32dp\"\n      android:text=\"Sign Up\"\n      app:layout_constraintStart_toStartOf=\"parent\"\n      app:layout_constraintTop_toBottomOf=\"@+id/textView2\" />\n\n    <Button\n      android:id=\"@+id/logIn\"\n      android:layout_width=\"169dp\"\n      android:layout_height=\"wrap_content\"\n      android:layout_marginStart=\"8dp\"\n      android:layout_marginTop=\"8dp\"\n      android:layout_marginEnd=\"8dp\"\n      android:text=\"Log In\"\n      app:layout_constraintBottom_toBottomOf=\"@+id/signUp\"\n      app:layout_constraintEnd_toEndOf=\"parent\"\n      app:layout_constraintHorizontal_bias=\"1.0\"\n      app:layout_constraintStart_toEndOf=\"@+id/signUp\"\n      app:layout_constraintTop_toBottomOf=\"@+id/password\"\n      app:layout_constraintVertical_bias=\"1.0\" />\n  </androidx.constraintlayout.widget.ConstraintLayout>\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n~~~\n\n\n\n\n"
    },
  
    {
    "title": "# Login View/Presenter",
    "shortTitle": "03",
    "contentMd" : "# Login View/Presenter\n\nOur first version will just let the user signup/login without paying any attention to what they enter as credentials.\n\n## LoginPresenter\n\n~~~\npackage org.wit.placemark.views.login\n\nimport org.wit.placemark.views.BasePresenter\nimport org.wit.placemark.views.BaseView\nimport org.wit.placemark.views.VIEW\n\nclass LoginPresenter(view: BaseView) : BasePresenter(view) {\n\n  fun doLogin(email: String, password: String) {\n    view?.navigateTo(VIEW.LIST)\n  }\n\n  fun doSignUp(email: String, password: String) {\n    view?.navigateTo(VIEW.LIST)\n  }\n}\n~~~\n\n## LoginView\n\n~~~\npackage org.wit.placemark.views.login\n\nimport android.os.Bundle\nimport kotlinx.android.synthetic.main.activity_login.*\nimport org.jetbrains.anko.toast\nimport org.wit.placemark.R\nimport org.wit.placemark.views.BaseView\n\nclass LoginView : BaseView() {\n\n  lateinit var presenter: LoginPresenter\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_login)\n    init(toolbar, false)\n\n    presenter = initPresenter(LoginPresenter(this)) as LoginPresenter\n\n    signUp.setOnClickListener {\n      val email = email.text.toString()\n      val password = password.text.toString()\n      if (email == \"\" || password == \"\") {\n        toast(\"Please provide email + password\")\n      }\n      else {\n        presenter.doSignUp(email,password)\n      }\n    }\n\n    logIn.setOnClickListener {\n      val email = email.text.toString()\n      val password = password.text.toString()\n      if (email == \"\" || password == \"\") {\n        toast(\"Please provide email + password\")\n      }\n      else {\n        presenter.doLogin(email,password)\n      }\n    }\n  }\n}\n~~~\n\nIn the above, note that we just start the PlacemarkListView, regardless of which button is pressed - or what is entered.\n\nThe manifest needs to be altered to now nominate this LoginView as the `launch` activity:\n\n~~~\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  package=\"org.wit.placemark\">\n\n  <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n\n  <application\n    android:name=\".main.MainApp\"\n    android:allowBackup=\"true\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:roundIcon=\"@mipmap/ic_launcher_round\"\n    android:supportsRtl=\"true\"\n    android:theme=\"@style/AppTheme\">\n\n    <activity android:name=\".views.login.LoginView\"\n      android:label=\"@string/title_activity_login\"\n      android:launchMode=\"singleTop\">\n      <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n      </intent-filter>\n    </activity>\n\n    <activity android:name=\".views.placemarklist.PlacemarkListView\"\n      android:label=\"@string/title_activity_placemark_list\"\n      android:launchMode=\"singleTop\">\n    </activity>\n\n    <activity android:name=\".views.placemark.PlacemarkView\"\n      android:label=\"@string/title_activity_placemark\">\n      <meta-data\n        android:name=\"android.support.PARENT_ACTIVITY\"\n        android:value=\".views.placemarklist.PlacemarkListView\" />\n    </activity>\n\n    <activity\n      android:name=\".views.editlocation.EditLocationView\"\n      android:label=\"@string/title_activity_edit_location\">\n      <meta-data\n        android:name=\"android.support.PARENT_ACTIVITY\"\n        android:value=\".views.placemark.PlacemarkView\" />\n    </activity>\n\n    <activity\n      android:name=\".views.map.PlacemarkMapView\"\n      android:label=\"@string/title_activity_placemark_maps\"\n      android:launchMode=\"singleTop\">\n      <meta-data\n        android:name=\"android.support.PARENT_ACTIVITY\"\n        android:value=\".views.placemarklist.PlacemarkListView\" />\n    </activity>\n\n    <meta-data\n      android:name=\"com.google.android.geo.API_KEY\"\n      android:value=\"@string/google_maps_key\" />\n\n  </application>\n\n</manifest>\n~~~\n\nRun the app now - it should display the login activity first, and take you to the placemark list when you press either button.\n\n\n"
    },
  
    {
    "title": "# Logout",
    "shortTitle": "04",
    "contentMd" : "# Logout\n\nAs we now support log in - we also need to support logout. This will require a change to our existing menus in PlacemarkListView. Once logged in the AppBar will be reconfigured to have a drop down menu:\n\n![](img/03x.png)\n\n![](img/04x.png)\n\nFirst, some new/revised strings:\n\n## res/values/strings.xml\n\n~~~\n  <string name=\"menu_showMap\">Show Map</string>\n  <string name=\"menu_logout\">Logout</string>\n~~~\n\nThis is the revised menu \n\n## memu_main.xml\n\n~~~\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n  <item\n    android:id=\"@+id/item_add\"\n    android:icon=\"@android:drawable/ic_menu_add\"\n    android:title=\"@string/menu_addPlacemark\"\n    app:showAsAction=\"never\"/>\n\n  <item\n    android:id=\"@+id/item_map\"\n    android:icon=\"@android:drawable/ic_menu_mapmode\"\n    android:title=\"@string/menu_showMap\"\n    app:showAsAction=\"never\"/>\n\n  <item\n    android:id=\"@+id/item_logout\"\n    android:title=\"@string/menu_logout\"\n    android:visible=\"true\"\n    app:showAsAction=\"never\" />\n</menu>\n~~~\n\nIn order to Launch a view, we have been encapsulating the start procedure in BaseView:\n\n## BaseView\n\n~~~\n...\nimport org.wit.placemark.views.login.LoginView\n...\nenum class VIEW {\n  LOCATION, PLACEMARK, MAPS, LIST, LOGIN\n}\n...\n\n  fun navigateTo(view: VIEW, code: Int = 0, key: String = \"\", value: Parcelable? = null) {\n    var intent = Intent(this, PlacemarkListView::class.java)\n    when (view) {\n      VIEW.LOCATION -> intent = Intent(this, EditLocationView::class.java)\n      VIEW.PLACEMARK -> intent = Intent(this, PlacemarkView::class.java)\n      VIEW.MAPS -> intent = Intent(this, PlacemarkMapView::class.java)\n      VIEW.LIST -> intent = Intent(this, PlacemarkListView::class.java)\n      VIEW.LOGIN -> intent = Intent(this, LoginView::class.java)\n    }\n    if (key != \"\") {\n      intent.putExtra(key, value)\n    }\n    startActivityForResult(intent, code)\n  }\n~~~\n\n\nWe need to be able to handle the new logout menu option. This is an extend version of the menu handler in PlacemarkListView:\n\n## PlacemarkListView\n\n~~~\n  override fun onOptionsItemSelected(item: MenuItem?): Boolean {\n    when (item?.itemId) {\n      R.id.item_add -> presenter.doAddPlacemark()\n      R.id.item_map -> presenter.doShowPlacemarksMap()\n      R.id.item_logout ->presenter.doLogout()\n    }\n    return super.onOptionsItemSelected(item)\n  }\n~~~\n\nFinally, this will need a new method in PlacemarkListPresenter:\n\n## PlacemarkListPresenter\n\n~~~\n  fun doLogout() {\n    view?.navigateTo(VIEW.LOGIN)\n  }\n}\n~~~\n\n\nNotice we are just switching to the login screen when logout is selected.\n\n\nTry this now, and make sure login and logout work as expected.\n"
    },
  
    {
    "title": "# Firebase",
    "shortTitle": "05",
    "contentMd" : "# Firebase\n\nVisit Firebase and create / log in to your account:\n\n- <https://firebase.google.com/>\n\nCreate a new Firebase Project:\n\n![](img/01.png)\n\n\nGive the project a name:\n\n![](img/02.png)\n\n\nOnce the app is created - you should see the application console (click on `Develop` to see drop down menu):\n\n![](img/03.png)\n\n\nSelect the `Authentication` panel - \n\n![](img/04.png)\n\nPress `Set Sign-in Method` and in the next screen and enable `Email/Password`:\n\n![](img/05.png)\n\nYour Authentication methods should look like this:\n\n![](img/06.png)\n"
    },
  
    {
    "title": "# Connect the App",
    "shortTitle": "06",
    "contentMd" : "# Connect the App\n\nBack in Android Studio, select `Tools->Firebase` - you should see the Firebase Assistant:\n\n![](img/07.png)\n\nSelect `Authentication`:\n\n![](img/08.png)\n\n... and then select `Email and password authentication`:\n\n![](img/09.png)\n\nNow press `Connect to Firebase`\n\nThis may require you to authenticate to firebase with your account. Once connected, you should see your firebase created app:\n\n![](img/10.png)\n\nSelect the app and press `Connect to Firebase`\n\nThis will insert a new file into your project called `google-services.json`. This file is embedded in the `app` folder. You will need to switch to the `Project` perspective in Studio in order to see it.\n\nThe assistant will also insert additional entries into both of our gradle files. The top level gradle will have this additional entry:\n\n## build.gradle\n \n~~~\n    classpath 'com.google.gms:google-services:4.0.1'\n~~~\n\nThe app gradle file will have additional libraries. As we are managing our gradle a little differently - we will take control of this ourselves. \n\nThis is a revised version of the base gradle file you should use:\n\n## project gradle\n\n~~~\napply plugin: 'com.android.application'\n\napply plugin: 'kotlin-android'\n\napply plugin: 'kotlin-android-extensions'\n\napply plugin: \"kotlin-kapt\"\n\napply plugin: 'com.google.gms.google-services'\n\nandroidExtensions {\n  experimental = true\n}\n\nandroid {\n  compileSdkVersion 28\n  defaultConfig {\n    applicationId \"org.wit.placemark\"\n    minSdkVersion 23\n    targetSdkVersion 28\n    versionCode 1\n    versionName \"1.0\"\n    testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n  }\n  buildTypes {\n    release {\n      minifyEnabled false\n      proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n    }\n  }\n}\n\next {\n  app_compat_version = '1.0.2'\n  constraint_layout_version = '2.0.0-alpha2'\n  material_version = '1.0.0'\n  cardview_version = '1.0.0'\n  design_library_version = '26.1.0'\n  support_library_version = '26.1.0'\n\n  play_services_maps_version = '16.0.0'\n  play_services_location_version = '16.0.0'\n\n  anko_version = '0.10.7'\n  anko_commons_version = '0.10.7'\n  gson_version = '2.8.5'\n\n  room_version = \"2.0.0\"\n  firebase_version = '16.0.5'\n}\n\ndependencies {\n  implementation fileTree(dir: 'libs', include: ['*.jar'])\n  implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\"\n  implementation \"androidx.appcompat:appcompat:$app_compat_version\"\n  implementation \"androidx.constraintlayout:constraintlayout:$constraint_layout_version\"\n  implementation \"com.google.android.material:material:$material_version\"\n  implementation \"androidx.cardview:cardview:$cardview_version\"\n  implementation \"com.google.android.gms:play-services-maps:$play_services_maps_version\"\n  implementation \"com.google.android.gms:play-services-location:$play_services_location_version\"\n  implementation \"org.jetbrains.anko:anko-commons:$anko_commons_version\"\n  implementation \"org.jetbrains.anko:anko:$anko_version\"\n  implementation \"com.google.code.gson:gson:$gson_version\"\n  implementation \"androidx.room:room-runtime:$room_version\"\n  kapt \"androidx.room:room-compiler:$room_version\"\n\n  implementation \"com.google.firebase:firebase-auth:$firebase_version\"\n  implementation \"com.google.firebase:firebase-database:$firebase_version\"\n\n  testImplementation 'junit:junit:4.12'\n  androidTestImplementation 'androidx.test:runner:1.1.0'\n  androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0'\n\n}\n~~~\n\nThese are the new features in the project:\n\n~~~\n...\napply plugin: 'com.google.gms.google-services'\n...\n  firebase_version = '16.0.5'\n  ...\n  implementation \"com.google.firebase:firebase-auth:$firebase_version\"\n  implementation \"com.google.firebase:firebase-database:$firebase_version\"\n...\n~~~\n\nRebuild the application now to make sure all of these libraries can be incorporated correctly.\n\n\n## google-service.json\n\nThe Firebase wizard will also have generate a file of various credentials for your app in \n\n- app/app/google-services.json\n\nHave a look at the contents of this file now. It contains multiple keys to facilitate authentication to your firebase app. You will need to exclude this from git, particularly if the repo is public:\n\n\n## .gitignore\n\n~~~\napp/google-services.json\n~~~\n\n"
    },
  
    {
    "title": "## Progress",
    "shortTitle": "07",
    "contentMd" : "## Progress\n\nWhen login in, we should display some indication to the user that we are 'working' on the login. This is usually via a `Progress` widget of some kind. Bring one in now to the login layout:\n\n![](img/17/png)\n\nIt might be structured like this in the layout:\n\n\n## activity_login.xml\n\n~~~\n...\n    <ProgressBar\n      android:id=\"@+id/progressBar\"\n      style=\"@style/Widget.AppCompat.ProgressBar\"\n      android:layout_width=\"196dp\"\n      android:layout_height=\"96dp\"\n      android:layout_marginStart=\"8dp\"\n      android:layout_marginTop=\"8dp\"\n      android:layout_marginEnd=\"8dp\"\n      android:layout_marginBottom=\"8dp\"\n      app:layout_constraintBottom_toBottomOf=\"parent\"\n      app:layout_constraintEnd_toEndOf=\"parent\"\n      app:layout_constraintStart_toStartOf=\"parent\"\n      app:layout_constraintTop_toBottomOf=\"@+id/signUp\" />\n...\n~~~\n\nIn LoginView we can then toggle this widget.\n\nFirst, in onCreate we can make it invisible (or GONE)\n\n~~~\n    progressBar.visibility = View.GONE\n~~~\n\n\nThen we can override the methods already defined in the BaseView class:\n\n## LoginView\n\n~~~\n  override fun showProgress() {\n    progressBar.visibility = View.VISIBLE\n  }\n\n  override fun hideProgress() {\n    progressBar.visibility = View.GONE\n  }\n}\n~~~"
    },
  
    {
    "title": "# Signup/Login Implementation",
    "shortTitle": "08",
    "contentMd" : "# Signup/Login Implementation\n\nBack in the LoginPresenter class - we can implement the Firebase login strategy:\n\n\n## LoginPresenter\n\n~~~\npackage org.wit.placemark.views.login\n\nimport com.google.firebase.auth.FirebaseAuth\nimport org.jetbrains.anko.toast\nimport org.wit.placemark.views.BasePresenter\nimport org.wit.placemark.views.BaseView\nimport org.wit.placemark.views.VIEW\n\nclass LoginPresenter(view: BaseView) : BasePresenter(view) {\n\n  var auth: FirebaseAuth = FirebaseAuth.getInstance()\n\n  fun doLogin(email: String, password: String) {\n    view?.showProgress()\n    auth.signInWithEmailAndPassword(email, password).addOnCompleteListener(view!!) { task ->\n      if (task.isSuccessful) {\n        view?.navigateTo(VIEW.LIST)\n      } else {\n        view?.toast(\"Sign Up Failed: ${task.exception?.message}\")\n      }\n      view?.hideProgress()\n    }\n  }\n\n  fun doSignUp(email: String, password: String) {\n    view?.showProgress()\n    auth.createUserWithEmailAndPassword(email, password).addOnCompleteListener(view!!) { task ->\n      if (task.isSuccessful) {\n        view?.navigateTo(VIEW.LIST)\n      } else {\n        view?.toast(\"Sign Up Failed: ${task.exception?.message}\")\n      }\n      view?.hideProgress()\n    }\n  }\n}\n~~~\n\nThis will sign up a new user with the Firebase service. Try it now \n\nMake sure to enter a correctly formed email + a password of at least 8 characters.\n\nThe application should take you to the main Placemarks screen.\n\nBack in the Firebase console - check the authentication panel to see if the new user is recorded:\n\n![](img/12.png)"
    },
  
    {
    "title": "#Solution",
    "shortTitle": "Exercises",
    "contentMd" : "#Solution\n\nPlacemark application so far:\n\n- [archive.zip](archives/archive.zip)\n\n## Exercise 1\n\nImplement logout. This is the FirebaseAuth method we need:\n\n- <https://firebase.google.com/docs/reference/android/com/google/firebase/auth/FirebaseAuth.html#signOut()>\n\n## Exercise 2\n\nAdjust the title of the PlacemarkListActivity - such that it displays the logged in users email:\n\n![](img/13.png)\n\nThe logged in user details are reasonably easy to locate:\n\n- <https://firebase.google.com/docs/auth/web/manage-users>\n\nHere is how we could access this in kotlin:\n\n~~~\n    val user = FirebaseAuth.getInstance().currentUser\n~~~"
    }
  
  ]
  }

